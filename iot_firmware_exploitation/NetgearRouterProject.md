# Goal
I pulled the firmware for the Pro gaming router (version XR700-V1.0.1.50) and want to get its webpage running. I binwalked it, and noticed that it is running on a arm32 (little endian) linux box which makes things slightly easier. I then began walking through the extracted file system.

## Where to look first
One of the first places to go to is the `inittab` file that exsists in the `/etc` directory since this is run by the system on boot and often kicks off a whole bunch of other processes. I saw that `inittab` called `/etc/init.d/rcS S boot` so I went to that file next and saw what the 2 args it passed to it did. In there, I saw that it went to `/etc/rc.d/ and ran any file than began with the first arg (S). Note: attempting to run inittab just threw hella errors since I didn't have any of the hardware devices that it was expecting when creating partitions, mappings, and so on.

There is a massive amount that can be learned here, such as how things are configured from certs, bus, net, usb, cron, watchdogs, and what I cared about, uhttpd. So I then looked into `etc/rc.d/S96uhttpd` (which is a shell script) and saw that it can be run with `start`, `stop`, or `stop_instance`. Running it with start runs the following `/www/cgi-bin/uhttpd.sh start` which is getting closer to what we actually want. I then looked at the script and saw that it was running the executable `/usr/sbin/uhttpd` with a shitton of args and figured I was in a good enough place to attempt to start it.

## Running UHTTPD
A recently learned a trick that works when the firmware dump is from a linux box. It will come with `/bin/busybox` in almost all cases or you can move a statically compiled version of it (compiled to the binaries on the host machine). I run the following command to be able to practically have the full functionality of properly setting up qemu-system `sudo chroot . /bin/busybox sh`. Note about `qemu-system`: as noted in other docs, it requires a kernel executable which can be acquired from using `vmlinux-to-elf` which (if it works) returns the executable file. Then once it's running (if it can, sometimes requiers a flash file too which I haven't figured out yet) you can move over rootfs. Optimally you can set up a tun tap and allow for netowrking. 

When I attempted to run `/www/cgi-bin/uhttpd.sh start`, it gave an error immediately about "a failed partition". After diving around, I found that the error was occuring in a shared library used for cryptography.

## Next Step
Possibly the error came from the system not being confirgured properly yet, so I attempted to run the `inittab` script to settup the entire thing... but here are some of the errors (out of the thousands) that were generated:
  - sysinit: mkdir: cannot create directory '/var/': Not a directory
  - sysinit: /sbin/mtd_name_alias: /sbin/mtd_name_alias: 41: cannot open /proc/mtd: No such file
  - sysinit: libmtd: error!: "/dev/" is not a character device
  - sysinit: nanddump: error!: mtd_get_dev_info failed
  - sysinit: wc: /tmp/config_data: No such file or directory
  - sysinit: sh: 262144: unknown operand
  - sysinit: cat: /proc/mtd: No such file or directory
  - sysinit: libmtd: error!: "/dev/" is not a character device
  - sysinit: nanddump: error!: mtd_get_dev_info failed
  - sysinit: wc: /tmp/config_data: No such file or directory
  - sysinit: sh: 262144: unknown operand
  - sysinit: cat: /proc/mtd: No such file or directory

So since that failed miserably, I instead am now hooking the funciton in the shared executable that is causing the error. The following are tips for hooking functions.

### Generic compilation with shared objects
Create a small c program that mathces the function signature of what you are trying to hook. Cross compile it to the architecure of the system with `gcc -shared -fPIC hook.c -o hook.so`. Below is a sample of what the code looks like for hooking a function `get_partition_device_path`
```
// hook.c
#include <stdlib.h>
#include <stdio.h>

// Function that will replace the original function
void get_partition_device_path(void)
{
    printf("get_partition_device_path hooked!\n");
    exit(0);
}
```
Then create a main.c that calls your function for testing purposes. When compiled correctly and linked correctly, you can see it with `ldd`. Below are 2 examples of compiling and linking, one that's correct and one that is incorrect. 

```                                                                                                         
┌──(kali㉿kali)-[~/…/squashfs-root/www/cgi-bin/test]
└─$ gcc main.c -o main -L./ target.so -Wl,-rpath=./ 
                                                                                                                    
┌──(kali㉿kali)-[~/…/squashfs-root/www/cgi-bin/test]
└─$ ./main 
In main
This is the original target function.
                                                                                                                    
┌──(kali㉿kali)-[~/…/squashfs-root/www/cgi-bin/test]
└─$ ldd main
        linux-vdso.so.1 (0x00007fff259f9000)
        target.so => ./target.so (0x00007f9be3b06000)
        libc.so.6 => /lib/x86_64-linux-gnu/libc.so.6 (0x00007f9be390e000)
        /lib64/ld-linux-x86-64.so.2 (0x00007f9be3b12000)
                                                                                                                    
┌──(kali㉿kali)-[~/…/squashfs-root/www/cgi-bin/test]
└─$ gcc main.c -o main -L./ target.so

┌──(kali㉿kali)-[~/…/squashfs-root/www/cgi-bin/test]
└─$ ./main 
./main: error while loading shared libraries: target.so: cannot open shared object file: No such file or directory           

┌──(kali㉿kali)-[~/…/squashfs-root/www/cgi-bin/test]
└─$ ldd main
        linux-vdso.so.1 (0x00007ffebe5d6000)
        target.so => not found
        libc.so.6 => /lib/x86_64-linux-gnu/libc.so.6 (0x00007f216dc8e000)
        /lib64/ld-linux-x86-64.so.2 (0x00007f216de8d000)

```
I then created another shared object with the same named function and ran the following
```
┌──(kali㉿kali)-[~/…/squashfs-root/www/cgi-bin/test]
└─$ LD_PRELOAD=./hook.so ./main
In main
This is the hooking function.
```
And you can see that the hooking function is now getting called.

### Now to hook the problem function
TODO: everything
If I have issues, look into where the executable expects to find its libraries.
