Notes taken from the IoT Firmware Exploitation class run by Tactical Network Solutions.

# Beginner's Guide to Firmware Ripping

Overview of steps:
- Identify a point on the router through which you can interface with the hardware
- Connect to the device using an adapter
- Determine the baud rate of the interface
- exfiltrate the filesystem
	- Move a small program to the router to help exfiltrate files
	- Run that program
		- chmod
		- ip a
		- miniterm / device_communicator
	- nc to the program
		- watch
	- extract the files

## Determining the Baud Rate
There are a couple ways to determine the buad rate - the first method is easier but I'm not sure if it always works. Before beginning either method, ensure you're hardware adapter is connected correctly and that the router is powered on. If you're using a virtual machine, make sure you've given your VM permission to access the usb port corresponding to the hardware adapter you're using. 

### stty
Simply run `stty -F /dev/ttyUSB0` and it should output the baudrate. If later steps in this guide aren't working, maybe your baud rate is off - try the other method for determing the baud rate.

### baudrate.py
[`baudrate.py`](https://github.com/tristan-white/baudrate) reads output from the router and prints it to your terminal. When using this tool, you can cycle through differnt baud rates using the down arrow key.

Run the file (`sudo python baudrate -p /dev/ttyUSB0`). If your adapter was set up correctly, you may see gibberish printed to the screen since `baudrate.py` guessed which baud rate the router is using. Press the down arrow key to change the baud rate until you see ASCII characters printed to the screen. Note this baudrate - you'll need it later.

## Exfiltrate the Firmware
We can use the UART adapter to talk to the router but not send and recieve files. We can send/receive files using the UART, but the transfer rate is extremely slow - for me it was about 80 bits/s. Since we're going to have several MB of data we're going to want to copy to exfiltrate, this isn't a great option since that would take about half a day or longer. One way we can do this faster is to upload a small program to the router that takes reads in data, listens for a netcat connection, and then sends the data to anybody that connects.

The program [`exfil.mipsel`](https://drive.google.com/file/d/17AvJecUR4Zv6J38bTupVRV3dmMUyozc8/view?usp=share_link) (the "el" in "mipsel" stands for "endian little") can do this. We'll also need the program [`serio.py`](https://github.com/tristan-white/serio), which will let us write a file to the router via the UART serial port. We'll have to provide this program the buad rate we found earlier. An example run looks like:

`$ sudo python3 serio.py -s <SOURCE> -b <BAUDRATE> -p /dev/ttyUSB0 -d <DEST>`

An important note is that you should write your exfiltration program to the `/tmp` directory on the router because it's probably the only directory you'll be able to write to. The command that I ran on my machine was:

`$ sudo python3 serio.py -s ./exfil.mipsel -b 57600 -p /dev/ttyUSB0 -d /tmp/exfil.mipsel`

### Pop a shell and find rootfs
Now that the program is on the router, we want it to run and read the root filesystem of the router. Before we can do that, we need to find the location in memory of the root filesystem. We'll need a shell on the router to do this. To pop a shell, we can use the progrma [`miniterm.py`](https://gist.github.com/tristan-white/f713a779d2a6e771a7647243c5bdca3f) like so:

`$ sudo miniterm.py /dev/ttyUSB0 <BAUDRATE>`

> Note: this will pop a shell on the router that begins with a `#` character. In this guide, any commands starting with `$` are run on the computer connected to the router and all `#` commands are run in the router shell.

Now we have a shell. The root filesystem (rootfs) that we're seeking to exfiltrate is in flash memory, so we want to figure out which MTD corresponds to rootfs. An [MTD](https://en.wikipedia.org/wiki/Memory_Technology_Device) is a type of device file in Linux for interacting with flash memory. Use `cat` to enumerate the MTDs:

```bash
# cat /proc/mtd
dev: size erasesize name
mtd0: 000a0000 00020000 "uboot"
mtd1: 00420000 00020000 "kernel"
mtd2: 002c0000 00020000 "rootfs"	# mtd2 is the one we want
mtd3: 0fa00000 00020000 "nvram"
mtd4: 02800000 00020000 "default"
mtd5: 0af20000 00020000 "userdata"
```

Record which number mtd rootfs is at. Additionally, run `# ip a` and record the broadcast address. For me it was `192.168.0.1`. 

### Run exfiltration program
The exfiltration program will be using opening an network connection using an ethernet port, so plug your computer into the router (any port except the port for the modem) with an ethernet cable. Before running the exfiltration program, mark it as executable (`# chmod +x /tmp/exfil.mipsel`). Rootfs is located at `/dev/mtdblock/<MTD NUM>`; `cat` it's contents and pipe it to the exfiltration program:

`# cat /dev/mtdblock/2 | /tmp/exfil.mipsel`

Your router shell should hang as it opens a port and listens for connection. Using the ip address we found earlier, connect to it using netcat and save the output to a file called rootfs:

`$ nc <router address> 32896 > rootfs`

This may take a little while to complete. If you want to watch the progress of file transfer, go to the directory that is receiving the file `rootfs` and run `$ watch ls -l rootfs`.

> Note: the provided `exfil.mipsel` file opens a port on port 32896.

## Extract rootfs from the bytestream from /dev/mtdblock
We just extracted a stream of bytes that can't be interpreted into anything yet. To solve, we can use [`binwalk`](https://github.com/ReFirmLabs/binwalk). However, at the time of this writing binwalk has an issued that hasn't been patched yet so we'll have to fix in manually; to do this, follow the instructions in [this post](https://gist.github.com/thanoskoutr/4ea24a443879aa7fc04e075ceba6f689#fix-compile-errors). Run `$ binwalk -e rootfs` to extract into the rootfs that allows for file navigation like normal.

## Fully emulate the system
There are several emulation tools that exist (Firmadyne, Qemu, and Renode are a few that I listed in increasing difficulty and customization). Going forward we will be using Qemu to emulate the system. 

### When to use Qemu user vs system mode
#### User Mode
There is only 1 case where you should ever be using qemu user mode, when you need to simply run a single file (typically one that is very simple that lacks forking, or extensive library calls). User mode works by dynamically mapping the instructions into instructions of your native architecture during runtime, which causes for lots of variability.

#### System Mode
System mode allows for much greater emulation and if configured correctly, near full system emulation. What we will want to do is take our rootfs directory, and convert it to a .qcow2 file. The purpose of this  
